2025-12-05_PHASE2_CONTACTS_AND_PHASE_RENUMBERING.txt
======================================================

üéØ Objectif global
------------------
1. Harmoniser toutes les r√©f√©rences de phases du projet avec le plan officiel (Phase 0 ‚Üí 5), en particulier la m√©moire qui doit √™tre **Phase 2**, pas Phase 3.
2. Mettre en place le sch√©ma **Contact** dans la m√©moire (SQLite) en suivant les d√©cisions ci-dessous.

IMPORTANT : tu dois tout faire **dans ce repo Clara uniquement** et tout documenter dans `journal/cursor_gpt/`.

--------------------------------------------------
1) R√âNUM√âROTATION DES PHASES (Phase 3 ‚Üí Phase 2)
--------------------------------------------------

But : tout ce qui parle de ¬´ Phase 3 ¬ª pour la m√©moire doit devenir ¬´ Phase 2 ¬ª pour √™tre align√© avec le plan initial.

A. R√©f√©rentiel de v√©rit√©
------------------------
Le plan de r√©f√©rence est :

- Phase 0 ‚Äì Infrastructure
- Phase 1 ‚Äì Fondation Clara
- Phase 2 ‚Äì M√©moire solide
- Phase 3 ‚Äì UI Admin
- Phase 4 ‚Äì Agents outils
- Phase 5 ‚Äì Automatisation avanc√©e

Tu dois t‚Äôassurer que :
- `README.md` (roadmap) refl√®te exactement ce plan.
- `journal/dev_notes/2025-12-04_clara_project_plan.md` (et √©ventuelles variantes) est coh√©rent avec ce plan.

B. O√π corriger les phases
-------------------------

1. **README.md**
   - Met √† jour la section *Roadmap* pour qu‚Äôelle refl√®te le plan ci-dessus.
   - V√©rifie qu‚Äôaucune ligne ne dit encore ¬´ Phase 3 ‚Äì M√©moire ¬ª, etc.

2. **Journaux de dev**
   - Dans `journal/dev_notes/` :
     - Renomme tous les fichiers qui commencent par `2025-12-05_phase3_...` en `2025-12-05_phase2_...` s‚Äôils concernent la m√©moire.
     - √Ä l‚Äôint√©rieur de ces fichiers, remplace :
       - `Phase 3` ‚Üí `Phase 2` quand √ßa parle de m√©moire.
     - V√©rifie aussi `2025-12-05_phase3_memory_integration.md`, `2025-12-05_phase3_5_memory_todo_process_protocol.md`, etc.

3. **Journaux Cursor**
   - Dans `journal/cursor_gpt/` :
     - Corrige les titres et le contenu des fichiers qui parlent de ¬´ Phase 3 ¬ª pour la m√©moire ‚Üí ¬´ Phase 2 ¬ª.
     - Ne touche pas au contenu purement historique si c‚Äôest juste une citation utilisateur, mais tu peux ajouter une NOTE explicite en haut du fichier si besoin, par exemple :
       - `NOTE: √Ä partir du 2025-12-05, ce qui √©tait appel√© "Phase 3 (m√©moire)" est renomm√© en "Phase 2 (m√©moire solide)".`

4. **Autres fichiers √©ventuels**
   - Recherche globale dans le repo :
     - `Phase 3` 
     - `phase3_`
   - Pour chaque occurrence, v√©rifie **le contexte** :
     - Si c‚Äôest de la m√©moire/SQLite/notes/todo/process/protocol ‚Üí renommer en Phase 2.
     - Si c‚Äôest de l‚ÄôUI Admin ou d‚Äôautres sujets ‚Üí laisser en Phase 3.

C. Renommer aussi les commits (r√©√©criture de l‚Äôhistorique)
----------------------------------------------------------

Contexte : Jeremy est actuellement **le seul** √† travailler sur ce repo, et accepte que tu r√©√©crives l‚Äôhistorique pour avoir quelque chose de propre.

T√¢che :
1. Affiche le log r√©cent :
   - `git log --oneline --decorate`
2. Identifie les commits dont le message contient par exemple :
   - `Phase 3`
   - `phase3`
   - ou des intitul√©s qui d√©crivent la m√©moire comme Phase 3.
3. Fais une r√©√©criture de l‚Äôhistorique depuis le d√©but :
   - `git rebase -i --root`
   - Dans l‚Äô√©diteur, remplace les messages concern√©s :
     - `Phase 3` ‚Üí `Phase 2` **uniquement quand √ßa parle de m√©moire**.
4. Quand le rebase est propre : 
   - `git push --force origin main`

IMPORTANT :
- Documente cette op√©ration dans un nouveau fichier :
  - `journal/cursor_gpt/2025-12-05_phase_renumbering_history_rewrite.md`
  - Contenu minimum :
    - Contexte
    - Liste des commits modifi√©s (avant/apr√®s)
    - Commandes principales utilis√©es
    - R√©sultat final


--------------------------------------------------
2) SCH√âMA CONTACT ‚Äì M√âMOIRE SQLITE
--------------------------------------------------

Objectif : d√©finir et impl√©menter un format de contact coh√©rent, simple, mais d√©j√† exploitable.

A. Sch√©ma logique contact
--------------------------

On veut pouvoir repr√©senter un contact sous cette forme logique (JSON conceptuel) :

{
  "first_name": "Aur√©lie",
  "last_name": "Malai",
  "display_name": "Aur√©lie Malai",

  "aliases": ["ma femme", "mon √©pouse"],

  "category": "family",             // family | friend | client | supplier | other
  "relationship": "wife",           // wife, brother, cousin, best_friend, etc.

  "phones": [
    {
      "number": "+972-5x-xxx-xxxx",
      "label": "mobile perso",      // perso | pro | other (libre)
      "primary": true,
      "channels": ["call", "sms", "whatsapp"]
    }
  ],

  "emails": [
    {
      "address": "aurelie@example.com",
      "label": "perso",             // perso | pro | other (libre)
      "primary": true
    }
  ],

  "company": "Active Games",
  "role": "Associ√©e / co-fondatrice",

  "notes": [
    "Pr√©pare les deals fournisseurs LED",
    "Passeport FR + passeport ISR ‚Äì num√©ros √† ajouter plus tard"
  ]
}

D√©cisions finales importantes :
- `aliases` : **liste** d‚Äôalias possibles (ma femme, mon fr√®re, mon fr√©rot‚Ä¶).
- `importance` : **SUPPRIM√â** pour l‚Äôinstant (tous les contacts sont importants).
- `emails[].tags` : **SUPPRIM√â** ‚Üí on garde juste `label` + `primary`.
- `phones[].channels` : on garde (call/sms/whatsapp/telegram/etc.).
- Plusieurs t√©l√©phones / emails sont possibles, avec possibilit√© d‚Äôun `primary` par type (le code pourra plus tard √©viter de mettre plusieurs `primary` sur un m√™me type si on le souhaite).

B. Impl√©mentation dans memory (SQLite)
--------------------------------------

1. `schema.sql`
   - V√©rifie la table `memory` existante.
   - On **ne change pas** la structure de base (id, type, content, tags, created_at, updated_at).
   - On documente dans des commentaires le format attendu pour `type = "contact"`, par exemple :

   - For type = 'contact', content is a JSON object with:
     - first_name, last_name, display_name
     - aliases: [string]
     - category: 'family' | 'friend' | 'client' | 'supplier' | 'other'
     - relationship: string (wife, brother, best_friend, ...)
     - phones: [ { number, label, primary, channels[] } ]
     - emails: [ { address, label, primary } ]
     - company: string | null
     - role: string | null
     - notes: [string]

2. `memory/memory_core.py`
   - Ajouter des helpers d√©di√©s aux contacts **sans casser** les fonctions existantes :
     - `save_contact(contact: dict) -> int`
       - Valide et normalise le dict contact.
       - Sauvegarde dans `memory` avec `type = "contact"`.
     - `update_contact(contact_id: int, updates: dict) -> None`
       - Charge le contact existant, applique les updates, resauvegarde.
     - `find_contacts(query: str) -> List[dict]`
       - Recherche par nom, alias, email, t√©l√©phone, company‚Ä¶ (match simple pour l‚Äôinstant).
   - Les helpers doivent s‚Äôappuyer sur le m√©canisme g√©n√©rique d√©j√† en place :
     - `save_memory_item`
     - `search_memory`
     - etc.

3. Tests unitaires
   - Dans `tests/test_memory_core.py` :
     - Ajouter des tests simples :
       - Cr√©ation d‚Äôun contact minimal (first_name + au moins un phone).
       - Cr√©ation avec plusieurs `phones` et `emails`.
       - Recherche d‚Äôun contact par alias, par email, par t√©l√©phone.
   - Les tests doivent utiliser une base SQLite temporaire (comme les tests existants).

C. Int√©gration future avec Clara
--------------------------------
Pour cette √©tape, tu **pr√©pares seulement** les helpers c√¥t√© m√©moire.
La vraie int√©gration dans l‚Äôorchestrator (intentions ‚Äúcontact‚Äù) viendra dans une phase suivante.

Documente cette phase dans :
- `journal/dev_notes/2025-12-05_phase2_contacts_schema.md`
  - Contexte
  - Sch√©ma final retenu
  - D√©cisions (importance supprim√©e, tags email supprim√©s, etc.)
- `journal/cursor_gpt/2025-12-05_phase2_contacts_implementation.md`
  - Ce que tu as r√©ellement fait (fichiers modifi√©s, tests, etc.)

--------------------------------------------------
3) FIN DE MISSION
--------------------------------------------------

√Ä la fin :
- Tous les fichiers du repo doivent √™tre coh√©rents avec le plan de phases officiel.
- L‚Äôhistorique Git (messages de commits) ne doit plus parler de ‚ÄúPhase 3‚Äù pour la m√©moire.
- Le sch√©ma contact doit √™tre document√© et les helpers de base pr√©sents dans `memory_core.py`.
- Les journaux dans `journal/` doivent refl√©ter clairement ces changements.
